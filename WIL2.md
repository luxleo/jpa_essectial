# 지연로딩과 프록시
## 프록시
    1.em.find(Member.class,m1.getId()), em.getReference(Member.class, m.getId())
        두 가지 방법으로 객체를 만든다.
        전자는 진성으로 db를 조회하여 만든 엔티티 객체이고
        후자는 정말 엔티티를 참조할일(getUserName()등)이 있는 경우에만 영속성컨텍스트를 통해 
        엔티티 객체를 참조하는 녀석이다.
    2. em.getReference() -> 프록시 객체 반환
        프록시 객체는 바로 엔티티객체를 조회하지 않는다.
        대신 정말 참조가 발생하는 경우에만 영속성 컨텍스트를 통하여 디비를 조회한다.
        따라서 em.close(),em.detatch(proxyEntity), em.clear()로 각각 
        영속성 컨텍스트를 종료, 준영속상태로 전환, 영속성 컨텍스트 정리를 할 경우 에러가 발생한다.(Lazy 뭐시기)
    3. 또한 @Transaction 혹은 영속성 컨텍스트 내에서 
        엔티티객체-프록시 객체, 엔티티-엔티티, 프록시-프록시등 서로 같거나 상이한 타입을 비교하더라도
        JPA는 같은 타입이 되도록 해준다. 허나, 서로 다른 영속성 컨텍스트에 위치 한다면 == 연산이 false가 된다.
        따라서 항상 '(프록시,엔티티) isinstanceof (타입)'으로 비교하도록 하자
    4. 프록시 객체는 지연, 즉시 로딩을 이해하는 기본이다.
## 지연로딩, 즉시로딩
    지연로딩(Lazy loading)은 xToOne관계에서 연관된 엔티티를 직접 가져오지 않는다.
    앞서 배운 프록시 객체로 가져와두고, 실제 참조 할때 엔티티 객체를 참조한다.
    순서: 영속성 컨텍스트 -> db 조회 -> entity객체 생성 -> 생성된 entity객체 참조
    즉 한번 프록시 객체인 상태에서는 계속 프록시 객체이다.
    
    즉시로딩(Eager loading): 'select m from Member m'등의 단일 테이블 조회 쿼리 발생시에도
    반환후 그 즉시 연관관계 테이블의 엔티티들을 몽땅 조회한다.
    만일 한 테이블의 연관관계 테이블이 10개라고 생각해보자.
    쿼리문의 길이는 안드로메다롤 향한다. + 1+N 문제의 주범
    
    전략: 모든 연관관계는 lazy로딩으로 한다.
    조인의 해결:
        join fetch, entity 그래프 이용하여 join쿼리로 해결한다.
## 영속 컨텍스트 전이 밑 orphanRemoval=true WITH DDD.AggregateRoot
    1. xToOne의 cascade=CascadeType.All등으로 연관 매핑된 녀석과 함께 움직인다.
        em.persist, em.remove등이 적용된 엔티티와 그 매핑된 녀석이 함께 적용
    2. orphanRemoval=true에 의하여 콜렉션 등에서 빠지면 바로 제거 된다.
    *3. 적용할 조건: 하나의 엔티티만 소유하고 있을때, 라이프 사이클이 같을때.
    4. DDD의 aggregate root개념을 충실히 적용할 수 있다. -> 부모 엔티티의 리포지토리로 자식 엔티티의 레포지토리 구현없이 관리한다는 개념이다.
    